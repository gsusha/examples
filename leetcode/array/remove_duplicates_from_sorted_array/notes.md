# Размышления:

## Set

В задаче явно указано, что массив должен быть изменён in-place, то есть без использования дополнительной памяти.
Использование Set потребовало бы хранения элементов вне исходного массива, что увеличило бы сложность по памяти до `O(n)`.

Если бы массив не был отсортирован, Set мог бы быть допустимым решением, но в текущих условиях он не нужен.

## Недостаточная длина

Для массивов длины 0 или 1 дубликатов быть не может, поэтому можно сразу вернуть количество уникальных элементов `k`.

## Почему важно, что массив отсортирован

Так как массив отсортирован, все дубликаты находятся рядом. Это позволяет удалить их за один проход,
не используя дополнительные структуры данных.

В текущих условиях решение имеет:
- `O(n)` по времени
- `O(1)` по памяти

Альтернативные подходы:
- Использование `Set` увеличило бы сложность по памяти до `O(n)`
- Сортировка массива привела бы к сложности `O(n log n)` по времени

## Решение

Используем два указателя:
- один проходит по массиву
- второй указывает позицию для записи следующего уникального элемента
